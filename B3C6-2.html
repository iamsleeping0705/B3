<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å…ƒç´ ç‰¹å·¥ï¼šç‰©è³ªåˆ†æè¡Œå‹•</title>
    <style>
        /* å…¨åŸŸè¨­å®š */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #2c3e50; /* æ·±è—ç°èƒŒæ™¯ */
            font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif;
            touch-action: none; /* ç¦æ­¢é è¨­è§¸æ§è¡Œç‚º */
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* ç™»å…¥ä»‹é¢ */
        #loginOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            width: 320px;
            z-index: 100;
        }

        #loginOverlay h1 {
            color: #2c3e50;
            margin: 0 0 20px 0;
            font-size: 24px;
        }

        .input-group {
            margin-bottom: 20px;
            text-align: left;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }

        input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
            transition: border-color 0.3s;
        }

        input:focus {
            border-color: #3498db;
        }

        button {
            background: linear-gradient(135deg, #ff6b6b, #ee5253);
            color: white;
            border: none;
            padding: 14px 28px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            box-shadow: 0 4px 15px rgba(238, 82, 83, 0.4);
            transition: transform 0.1s;
        }

        button:active {
            transform: scale(0.98);
        }

        .hidden {
            display: none !important;
        }
        
        /* é å°¾ç½²å */
        .footer-credit {
            font-size: 12px;
            color: #95a5a6;
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 10px;
            line-height: 1.5;
        }
    </style>
</head>
<body>

    <!-- ç™»å…¥ä»‹é¢ -->
    <div id="loginOverlay">
        <h1>ğŸ§ª å…ƒç´ åˆ†æä»»å‹™</h1>
        <div class="input-group">
            <label>ç­ç´š (ä¾‹å¦‚: 211)</label>
            <input type="number" id="classId" placeholder="è¼¸å…¥ç­ç´š">
        </div>
        <div class="input-group">
            <label>åº§è™Ÿ (ä¾‹å¦‚: 051321)</label>
            <input type="text" id="seatId" placeholder="è¼¸å…¥åº§è™Ÿä¸² (å¦‚051321)">
        </div>
        <button onclick="startGame()">å•Ÿå‹•ä»»å‹™</button>
        <p style="font-size: 12px; color: #7f8c8d; margin-top: 15px;">
            è«‹ä½¿ç”¨ iPad æ©«å‘æ“ä½œ<br>æ‹–æ›³é…å°ï¼å»ºç«‹æª”æ¡ˆ
        </p>
        <div class="footer-credit">
            sleepingèˆ‡Geminiè¨­è¨ˆ<br>2026.å—ä¸€
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * éŠæˆ²è³‡æ–™åº«
 */
const elementsDB = [
    { id: 'Al', name: 'é‹', isMetal: true,  desc: 'èˆ‡æ°§åæ‡‰å½¢æˆç·»å¯†æ°§åŒ–å±¤ä¿è­·å…§éƒ¨ï¼Œåˆé‡‘å¯†åº¦å°ä¸”å …ç¡¬ï¼Œç”¨æ–¼èˆªå¤ªç”¢æ¥­(é£›æ©Ÿ)ã€‚' },
    { id: 'Au', name: 'é‡‘', isMetal: true,  desc: 'æ€§è³ªå®‰å®šã€ä¸æ˜“èˆ‡æ°§åæ‡‰ï¼Œå»¶å±•æ€§æœ€ä½³çš„é‡‘å±¬ï¼Œå¸¸ç”¨ä¾†è£½é€ é£¾ç‰©ã€‚' },
    { id: 'Fe', name: 'éµ', isMetal: true,  desc: 'æ˜“ç”Ÿé½ï¼Œéœ€é›»éæˆ–è£½æˆåˆé‡‘ã€‚ç…‰é‹¼å¾Œå¯è£½æˆä¸é½é‹¼ï¼Œç”¨æ–¼è£½é€ é¤å…·å»šå…·ã€‚' },
    { id: 'Cu', name: 'éŠ…', isMetal: true,  desc: 'ç´…è‰²é‡‘å±¬ï¼Œå°é›»æ€§ä½³åƒ…æ¬¡æ–¼éŠ€ï¼Œè£½ä½œé›»ç·šï¼Œèˆ‡é‹…è£½æˆåˆé‡‘ç¨±ç‚ºé»ƒéŠ…ã€‚' },
    { id: 'Ti', name: 'éˆ¦', isMetal: true,  desc: 'æ°§åŒ–ç‰©ç‚ºç™½è‰²ç²‰æœ«ï¼Œç„¡æ¯’æ€§ï¼Œå¯è£½æˆä¿®æ­£å¸¶åŠé˜²æ™’ä¹³ç­‰ç”¢å“ã€‚' },
    { id: 'S',  name: 'ç¡«', isMetal: false, desc: 'ç„¡è‡­ç„¡å‘³è³ªè„†çš„é»ƒè‰²å›ºé«”ï¼Œå­˜åœ¨æ–¼ç«å±±å£èˆ‡æº«æ³‰å€ï¼Œå¯è£½ç«è—¥ã€‚' },
    { id: 'Si', name: 'çŸ½', isMetal: false, desc: 'åœ°æ®¼ä¸­å«é‡ç¬¬äºŒå¤§ï¼Œå°é›»æ€§ä»‹æ–¼å°é«”èˆ‡çµ•ç·£é«”ä¹‹é–“ï¼ŒåŠå°é«”å·¥æ¥­æ ¸å¿ƒã€‚' },
    { id: 'C',  name: 'ç¢³', isMetal: false, desc: 'çµæ§‹ä¸åŒçµ„æˆä¸åŒç‰©è³ª(åŒç´ ç•°å½¢é«”)ï¼Œä¾‹å¦‚ï¼šçŸ³å¢¨ã€é‘½çŸ³å’ŒèŠ™ã€‚' }
];

// éŠæˆ²ç‹€æ…‹è®Šæ•¸
let canvas, ctx;
let gameState = 'LOGIN'; // ç‹€æ…‹: LOGIN, LEVEL1, LEVEL1_END, LEVEL2, LEVEL2_RESULT
let level1Score = 0;
let level2Score = 0;
let finalScore = 0;

let timer = 0;
let timerInterval;
let level1Mistakes = []; 
let playerInfo = { class: '', seats: '' };

// æ‹–æ›³ç³»çµ±è®Šæ•¸
let dragItem = null;
let touchOffset = { x: 0, y: 0 };

// Level 1 å°ˆç”¨è®Šæ•¸
let level1Queue = []; 
let fallingItems = [];
let spawnTimer = 0;
let level1FinishedSpawning = false;

// Level 2 å°ˆç”¨è®Šæ•¸
let slots = [];
let cards = [];
let level2Submitted = false;
let submitBtn = { x: 0, y: 0, w: 160, h: 50 }; // é€å‡ºæŒ‰éˆ•
let level2Feedback = []; // å„²å­˜éŒ¯èª¤å›é¥‹

// ä¸Šå‚³ç‹€æ…‹
let uploadStatus = 'idle'; // 'idle', 'uploading', 'success', 'error'

// æµ®å‹•æç¤ºæ–‡å­—
let feedbacks = [];

// åˆå§‹åŒ–
window.onload = function() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
    
    // ç¶å®šäº‹ä»¶
    const events = ['mousedown', 'touchstart'];
    events.forEach(evt => canvas.addEventListener(evt, handleStart, {passive: false}));
    
    const moveEvents = ['mousemove', 'touchmove'];
    moveEvents.forEach(evt => canvas.addEventListener(evt, handleMove, {passive: false}));
    
    const endEvents = ['mouseup', 'touchend'];
    endEvents.forEach(evt => canvas.addEventListener(evt, handleEnd, {passive: false}));
    
    requestAnimationFrame(gameLoop);
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // è‹¥åœ¨ Level 2 æ—‹è½‰è¢å¹•ï¼Œé‡æ–°è¨ˆç®—æŒ‰éˆ•ä½ç½®ä»¥å…è·‘ç‰ˆ
    if(gameState === 'LEVEL2' || gameState === 'LEVEL2_RESULT') {
        submitBtn.x = canvas.width / 2 - submitBtn.w / 2;
        submitBtn.y = canvas.height - 80;
    }
}

function startGame() {
    const classInput = document.getElementById('classId').value;
    const seatInput = document.getElementById('seatId').value;
    
    if (!classInput || !seatInput) {
        alert("è«‹è¼¸å…¥å®Œæ•´çš„ç­ç´šèˆ‡åº§è™Ÿï¼");
        return;
    }
    
    playerInfo.class = classInput;
    playerInfo.seats = seatInput;
    
    document.getElementById('loginOverlay').classList.add('hidden');
    startLevel1();
}

// ==========================================
// Level 1: åˆ†é¡ç‰¹è¨“ (é€Ÿåº¦èª¿æ…¢)
// ==========================================

function startLevel1() {
    gameState = 'LEVEL1';
    level1Score = 40; // æ»¿åˆ†40ï¼Œæ¡æ‰£åˆ†åˆ¶
    fallingItems = [];
    level1Mistakes = [];
    level1FinishedSpawning = false;
    
    // 1. å»ºç«‹ä½‡åˆ— (ä¸é‡è¤‡)
    level1Queue = [];
    elementsDB.forEach(el => {
        level1Queue.push({ id: el.id, text: el.name, type: 'name', isMetal: el.isMetal });
        level1Queue.push({ id: el.id, text: el.id,   type: 'symbol', isMetal: el.isMetal });
    });
    
    // æ´—ç‰Œ
    level1Queue.sort(() => Math.random() - 0.5);
    
    timer = 60; 
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
        timer--;
        if (timer <= 0) {
            clearInterval(timerInterval);
            showFloatingText("æ™‚é–“åˆ°ï¼é€²å…¥ç¬¬äºŒé—œ", canvas.width/2, canvas.height/2, '#ff4757');
            setTimeout(startLevel2, 2000);
        }
    }, 1000);
}

// ==========================================
// Level 2: ç‰©è³ªæª”æ¡ˆ (é€å‡ºè¨ˆåˆ†åˆ¶ + è¨‚æ­£å›é¥‹)
// ==========================================

function startLevel2() {
    gameState = 'LEVEL2';
    level2Score = 0; // çµç®—æ™‚è¨ˆç®—
    level2Submitted = false;
    level2Feedback = [];
    uploadStatus = 'idle'; // é‡ç½®ä¸Šå‚³ç‹€æ…‹
    timer = 300; // 5åˆ†é˜
    
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
        timer--;
        if (timer <= 0) {
            // æ™‚é–“åˆ°è‡ªå‹•é€å‡º
            evaluateLevel2();
        }
    }, 1000);
    
    initLevel2Objects();
}

function initLevel2Objects() {
    slots = [];
    cards = [];
    
    const W = canvas.width;
    const H = canvas.height;
    
    // ç‰ˆé¢è¦åŠƒ
    const topMargin = 110;
    const bottomMargin = 120;
    const workspaceH = H - topMargin - bottomMargin;
    
    const slotW = W * 0.42; 
    const slotH = Math.min(120, workspaceH / 5.2);
    const gapY = 8;
    
    // å·¦å´ (é‡‘å±¬å€ - 5æ ¼)
    for (let i = 0; i < 5; i++) {
        slots.push({
            x: W * 0.04,
            y: topMargin + i * (slotH + gapY),
            w: slotW, h: slotH,
            type: 'metal',
            contents: { name: null, symbol: null, desc: null } 
        });
    }
    
    // å³å´ (éé‡‘å±¬å€ - 5æ ¼)
    for (let i = 0; i < 5; i++) {
        slots.push({
            x: W * 0.54,
            y: topMargin + i * (slotH + gapY),
            w: slotW, h: slotH,
            type: 'non-metal',
            contents: { name: null, symbol: null, desc: null }
        });
    }
    
    // é€å‡ºæŒ‰éˆ•ä½ç½®
    submitBtn.x = W / 2 - submitBtn.w / 2;
    submitBtn.y = H - 60;
    
    // ç”¢ç”Ÿå¡ç‰‡ - æ•£è½åœ¨ä¸‹æ–¹èˆ‡å´é‚Š
    const deckY = H - 100;
    const deckW = W;
    
    elementsDB.forEach(el => {
        cards.push(createCard(el.id, el.name, 'name', deckY, deckW));
        cards.push(createCard(el.id, el.id, 'symbol', deckY, deckW));
        cards.push(createCard(el.id, el.desc, 'desc', deckY, deckW));
    });
}

function createCard(id, text, type, deckY, deckW) {
    let w, h, color, textColor;
    
    if (type === 'name') {
        w = 60; h = 40;
        color = '#3498db'; 
        textColor = '#fff';
    } else if (type === 'symbol') {
        w = 60; h = 40;
        color = '#f1c40f'; 
        textColor = '#2c3e50';
    } else {
        w = 200; h = 50;
        color = '#ecf0f1'; 
        textColor = '#2c3e50';
    }

    return {
        id: id,
        text: text,
        type: type,
        // éš¨æ©Ÿåˆ†å¸ƒï¼Œé¿é–‹æŒ‰éˆ•
        x: Math.random() > 0.5 ? 20 + Math.random() * (deckW/2 - 100) : deckW/2 + 100 + Math.random() * (deckW/2 - 140),
        y: deckY + Math.random() * 50,
        w: w, h: h,
        color: color,
        textColor: textColor,
        slotIndex: -1 
    };
}

// ==========================================
// Level 2 è©•åˆ†ç³»çµ± (å«éŒ¯é¡Œåˆ†æ)
// ==========================================

function evaluateLevel2() {
    if(level2Submitted) return;
    level2Submitted = true;
    clearInterval(timerInterval);
    
    level2Feedback = [];
    
    // æª¢æŸ¥æ¯ä¸€å€‹æ’æ§½
    slots.forEach((slot, index) => {
        // æª¢æŸ¥æ’æ§½æ˜¯å¦æœ‰å…§å®¹
        let hasContent = slot.contents.name || slot.contents.symbol || slot.contents.desc;
        if (!hasContent) return;
        
        // æ‰¾å‡ºæ’æ§½çš„ã€Œä¸»è¦å…ƒç´  IDã€
        let mainId = slot.contents.name || slot.contents.symbol;
        if (!mainId && slot.contents.desc) mainId = slot.contents.desc; 
        
        if (!mainId) return;
        
        let elData = elementsDB.find(e => e.id === mainId);
        let slotIsCorrect = true;
        let mistakes = [];
        
        // 1. æª¢æŸ¥åˆ†é¡
        const isMetalSlot = slot.type === 'metal';
        if (elData.isMetal !== isMetalSlot) {
            slotIsCorrect = false;
            mistakes.push("å€åŸŸåˆ†é¡éŒ¯èª¤");
        }
        
        // 2. æª¢æŸ¥å¡ç‰‡åŒ¹é…
        if (slot.contents.name !== mainId) mistakes.push(slot.contents.name ? "ä¸­æ–‡åç¨±ä¸ç¬¦" : "ç¼ºä¸­æ–‡åç¨±");
        if (slot.contents.symbol !== mainId) mistakes.push(slot.contents.symbol ? "ç¬¦è™Ÿä¸ç¬¦" : "ç¼ºç¬¦è™Ÿ");
        if (slot.contents.desc !== mainId) mistakes.push(slot.contents.desc ? "æ€§è³ªä¸ç¬¦" : "ç¼ºæ€§è³ª");

        if (mistakes.length > 0) slotIsCorrect = false;

        if (!slotIsCorrect) {
            // å­˜å…¥æ­£ç¢ºç­”æ¡ˆè³‡è¨Šä»¥ä¾¿é¡¯ç¤º
            level2Feedback.push({
                element: elData.name,
                symbol: elData.id,
                category: elData.isMetal ? 'é‡‘å±¬' : 'éé‡‘å±¬',
                desc: elData.desc, 
                mistakes: mistakes
            });
        }
    });

    // è¨ˆç®—åˆ†æ•¸ (æ¯æ­£ç¢ºä¸€å¼µå¡ç‰‡ 2.5 åˆ†)
    let totalCardsCorrect = 0;
    slots.forEach(slot => {
         let mainId = slot.contents.name || slot.contents.symbol || slot.contents.desc;
         if(!mainId) return;
         let elData = elementsDB.find(e => e.id === mainId);
         const isMetalSlot = slot.type === 'metal';
         
         if(elData.isMetal === isMetalSlot) {
             if(slot.contents.name === mainId) totalCardsCorrect++;
             if(slot.contents.symbol === mainId) totalCardsCorrect++;
             if(slot.contents.desc === mainId) totalCardsCorrect++;
         }
    });
    
    level2Score = Math.floor(totalCardsCorrect * 2.5);
    finalScore = Math.max(0, level1Score + level2Score);
    
    gameState = 'LEVEL2_RESULT';
    
    // è‡ªå‹•ä¸Šå‚³æˆç¸¾
    submitScore();
}

// ==========================================
// éŠæˆ²è¿´åœˆ
// ==========================================

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

function update() {
    // æµ®å‹•æ–‡å­—å‹•ç•«
    for (let i = feedbacks.length - 1; i >= 0; i--) {
        let f = feedbacks[i];
        f.y -= 1;
        f.life--;
        if (f.life <= 0) feedbacks.splice(i, 1);
    }

    if (gameState === 'LEVEL1') {
        if (level1Queue.length > 0) {
            spawnTimer++;
            if (spawnTimer > 45 || fallingItems.length === 0) {
                let itemData = level1Queue.pop(); 
                fallingItems.push({
                    ...itemData, 
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: -60,
                    r: 35, 
                    vx: (Math.random() - 0.5) * 1, 
                    // [é€Ÿåº¦èª¿æ•´] è®Šæ…¢: 0.8 + éš¨æ©Ÿ
                    vy: 0.8 + Math.random() * 0.5, 
                    isDragging: false
                });
                spawnTimer = 0;
            }
        } else {
            level1FinishedSpawning = true;
            if (fallingItems.length === 0 && !dragItem) {
                setTimeout(startLevel2, 500);
            }
        }
        
        fallingItems.forEach(item => {
            if (!item.isDragging) {
                item.y += item.vy;
                item.x += item.vx;
                if(item.x < item.r || item.x > canvas.width - item.r) item.vx *= -1;
                if (item.y > canvas.height + 50) {
                    item.y = -50;
                    item.x = Math.random() * (canvas.width - 100) + 50;
                }
            }
        });
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // èƒŒæ™¯
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    if (gameState === 'LEVEL1') {
        drawLevel1();
    } else if (gameState === 'LEVEL2') {
        drawLevel2();
    } else if (gameState === 'LEVEL2_RESULT') {
        drawLevel2Result();
    }
    
    // æµ®å‹•æ–‡å­—
    feedbacks.forEach(f => {
        ctx.globalAlpha = Math.min(1, f.life / 20);
        ctx.fillStyle = f.color;
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(f.text, f.x, f.y);
        ctx.globalAlpha = 1;
    });
}

// ------------------------------------------
// Level 1 ç¹ªè£½
// ------------------------------------------
function drawLevel1() {
    // ç¹ªè£½å·¦å³åˆ†å‰²èƒŒæ™¯
    // å·¦é‚Šï¼šé‡‘å±¬å€ (æ·ºè—)
    ctx.fillStyle = 'rgba(52, 152, 219, 0.15)'; 
    ctx.fillRect(0, 0, canvas.width / 2, canvas.height);
    
    // å³é‚Šï¼šéé‡‘å±¬å€ (æ·ºç¶ )
    ctx.fillStyle = 'rgba(46, 204, 113, 0.15)'; 
    ctx.fillRect(canvas.width / 2, 0, canvas.width / 2, canvas.height);
    
    // ä¸­é–“åˆ†éš”ç·š
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 4;
    ctx.stroke();

    // èƒŒæ™¯å¤§å­—æ¨™ç¤º
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = 'bold 80px Arial';
    
    // é‡‘å±¬å€æ–‡å­—
    ctx.fillStyle = 'rgba(52, 152, 219, 0.3)';
    ctx.fillText("é‡‘å±¬å€", canvas.width / 4, canvas.height / 2);
    
    // éé‡‘å±¬å€æ–‡å­—
    ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
    ctx.fillText("éé‡‘å±¬å€", canvas.width * 0.75, canvas.height / 2);

    // è³‡è¨Šåˆ—
    ctx.fillStyle = '#ecf0f1';
    ctx.font = '20px Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText(`å‰©é¤˜æ™‚é–“: ${timer}s`, 20, 40);
    ctx.textAlign = 'right';
    ctx.fillText(`ç¬¬ä¸€é—œåˆ†æ•¸: ${level1Score}`, canvas.width - 20, 40);
    
    ctx.textAlign = 'center';
    ctx.font = '24px Arial';
    ctx.fillText(`ç¬¬ä¸€é—œï¼šç‰©è³ªåˆ†é¡ (å‰©é¤˜ç‰©ä»¶: ${level1Queue.length + fallingItems.length})`, canvas.width/2, 40);

    // ç¹ªè£½æ‰è½ç‰©ä»¶
    fallingItems.forEach(item => {
        ctx.beginPath();
        ctx.arc(item.x, item.y, item.r, 0, Math.PI * 2);
        ctx.fillStyle = item.type === 'name' ? '#ffffff' : '#f1c40f';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#fff';
        ctx.stroke();
        ctx.fillStyle = '#2c3e50';
        ctx.font = item.type === 'symbol' ? 'bold 28px Arial' : 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(item.text, item.x, item.y);
    });
}

// ------------------------------------------
// Level 2 ç¹ªè£½
// ------------------------------------------
function drawLevel2() {
    // é ‚éƒ¨è³‡è¨Šåˆ—
    ctx.fillStyle = '#34495e';
    ctx.fillRect(0, 0, canvas.width, 100);
    
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'left';
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`å­¸ç¿’ç›®æ¨™ï¼šå°‡å¡ç‰‡æ‹–è‡³ é‡‘å±¬(Metal) æˆ– éé‡‘å±¬(Non-metal) å€åŸŸ`, 20, 35);
    ctx.font = '18px Arial';
    ctx.fillStyle = '#bdc3c7';
    ctx.fillText(`è¨ˆåˆ†èªªæ˜ï¼šå…¨éƒ¨æ’å¥½å¾ŒæŒ‰ä¸‹æ–¹ã€Œé€å‡ºç­”æ¡ˆã€æ‰è¨ˆåˆ†ã€‚æ”¾éŒ¯å¯éš¨æ™‚æ‹¿å‡ºä¾†ä¿®æ”¹ã€‚`, 20, 70);

    ctx.fillStyle = '#f1c40f';
    ctx.textAlign = 'right';
    ctx.font = 'bold 24px Arial';
    ctx.fillText(`æ™‚é–“: ${Math.floor(timer/60)}:${(timer%60).toString().padStart(2,'0')}`, canvas.width - 20, 50);

    // ç¹ªè£½æ’æ§½
    slots.forEach(slot => {
        ctx.lineWidth = 2;
        if(slot.type === 'metal') {
            ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
            ctx.strokeStyle = '#3498db';
        } else {
            ctx.fillStyle = 'rgba(46, 204, 113, 0.1)';
            ctx.strokeStyle = '#2ecc71';
        }
        
        ctx.fillRect(slot.x, slot.y, slot.w, slot.h);
        ctx.strokeRect(slot.x, slot.y, slot.w, slot.h);
        
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        ctx.font = 'bold 40px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(slot.type === 'metal' ? 'Metal' : 'Non-M', slot.x + slot.w/2, slot.y + slot.h/2);
    });

    // ç¹ªè£½å¡ç‰‡
    const drawList = [
        ...cards.filter(c => !c.isDragging),
        ...cards.filter(c => c.isDragging)
    ];

    drawList.forEach(card => {
        if(card.isDragging) {
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 10;
        } else {
            ctx.shadowColor = 'transparent';
        }

        ctx.fillStyle = card.color;
        roundRect(ctx, card.x, card.y, card.w, card.h, 8);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = card.textColor;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'transparent';

        if(card.type === 'desc') {
            ctx.font = '14px Arial'; 
            wrapText(ctx, card.text, card.x + card.w/2, card.y + 14, card.w - 10, 16);
        } else if (card.type === 'symbol') {
            ctx.font = 'bold 22px Arial';
            ctx.fillText(card.text, card.x + card.w/2, card.y + card.h/2);
        } else {
            ctx.font = 'bold 18px Arial';
            ctx.fillText(card.text, card.x + card.w/2, card.y + card.h/2);
        }
    });
    
    // ç¹ªè£½é€å‡ºæŒ‰éˆ•
    drawSubmitButton();
}

function drawSubmitButton() {
    ctx.shadowColor = 'rgba(0,0,0,0.3)';
    ctx.shadowBlur = 5;
    ctx.shadowOffsetY = 3;
    
    ctx.fillStyle = '#e74c3c';
    roundRect(ctx, submitBtn.x, submitBtn.y, submitBtn.w, submitBtn.h, 25);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText("é€å‡ºç­”æ¡ˆ", submitBtn.x + submitBtn.w/2, submitBtn.y + submitBtn.h/2);
    
    ctx.shadowColor = 'transparent';
}

function drawLevel2Result() {
    // ç¹ªè£½èƒŒæ™¯ (Level 2 çš„ç•«é¢è®Šæš—)
    drawLevel2(); 
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0,0,canvas.width, canvas.height);
    
    // çµæœé¢æ¿
    const pW = Math.min(600, canvas.width - 40);
    const pH = Math.min(500, canvas.height - 40);
    const pX = (canvas.width - pW) / 2;
    const pY = (canvas.height - pH) / 2;
    
    ctx.fillStyle = '#fff';
    roundRect(ctx, pX, pY, pW, pH, 20);
    ctx.fill();
    
    // æ¨™é¡Œ
    ctx.fillStyle = '#2c3e50';
    ctx.textAlign = 'center';
    ctx.font = 'bold 32px Arial';
    ctx.fillText("ä»»å‹™çµç®—", canvas.width/2, pY + 50);
    
    // åˆ†æ•¸
    ctx.font = 'bold 24px Arial';
    ctx.fillText(`ç¬¬ä¸€é—œ: ${level1Score} / 40`, canvas.width/2, pY + 100);
    ctx.fillText(`ç¬¬äºŒé—œ: ${level2Score} / 60`, canvas.width/2, pY + 140);
    
    ctx.fillStyle = '#e74c3c';
    ctx.font = 'bold 40px Arial';
    ctx.fillText(`ç¸½åˆ†: ${finalScore}`, canvas.width/2, pY + 200);
    
    // éŒ¯èª¤å›é¥‹
    ctx.textAlign = 'left';
    ctx.font = '18px Arial';
    ctx.fillStyle = '#333';
    
    let startFY = pY + 250;
    if (level2Feedback.length === 0) {
        ctx.fillStyle = '#2ecc71';
        ctx.textAlign = 'center';
        ctx.fillText("å®Œç¾é”æˆï¼å…¨éƒ¨åˆ†ææ­£ç¢ºï¼", canvas.width/2, startFY);
    } else {
        ctx.fillText("âš ï¸ è¨‚æ­£å›é¥‹ (æ­£ç¢ºæ€§è³ªæ‘˜è¦)ï¼š", pX + 40, startFY);
        startFY += 30;
        ctx.font = '16px Arial';
        
        const displayLimit = Math.min(level2Feedback.length, 5);
        for(let i=0; i<displayLimit; i++) {
            let fb = level2Feedback[i];
            ctx.fillStyle = '#c0392b';
            
            // é¡¯ç¤ºæ­£ç¢ºç­”æ¡ˆèˆ‡æ€§è³ªæ‘˜è¦
            let errorText = fb.mistakes.join('ã€');
            let shortProp = fb.desc.substring(0, 12) + "...";
            
            ctx.fillText(`â— ${fb.element}(${fb.symbol})[${fb.category}]: ${shortProp}`, pX + 40, startFY + i*28);
            ctx.fillStyle = '#7f8c8d';
            ctx.fillText(`   (éŒ¯: ${errorText})`, pX + 40 + 350, startFY + i*28); 
        }
        if(level2Feedback.length > 5) {
             ctx.fillStyle = '#7f8c8d';
             ctx.fillText(`...é‚„æœ‰ ${level2Feedback.length - 5} å€‹éŒ¯èª¤`, pX + 40, startFY + 5*28);
        }
    }
    
    // è‡ªå‹•ä¸Šå‚³ç‹€æ…‹é¡¯ç¤ºå€åŸŸ
    const btnY = pY + pH - 60;
    ctx.textAlign = 'center';
    ctx.font = 'bold 20px Arial';

    if (uploadStatus === 'uploading') {
        ctx.fillStyle = '#f39c12';
        ctx.fillText("â³ æˆç¸¾ä¸Šå‚³ä¸­ï¼Œè«‹ç¨å€™...", canvas.width/2, btnY + 28);
    } else if (uploadStatus === 'success') {
        // ç¹ªè£½å®ŒæˆæŒ‰éˆ•
        ctx.fillStyle = '#27ae60';
        roundRect(ctx, canvas.width/2 - 80, btnY, 160, 45, 22);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.fillText("å®Œæˆ", canvas.width/2, btnY + 28);
    } else if (uploadStatus === 'error') {
        ctx.fillStyle = '#c0392b';
        ctx.fillText("âš ï¸ ä¸Šå‚³å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯æˆ–æˆªåœ–ç´€éŒ„", canvas.width/2, btnY + 28);
    }
}

// ==========================================
// äº’å‹•è™•ç†
// ==========================================

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.touches ? e.touches[0].clientX : e.clientX;
    const y = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: x - rect.left, y: y - rect.top };
}

function handleStart(e) {
    e.preventDefault();
    const pos = getPos(e);
    
    if (gameState === 'LEVEL1') {
        for (let i = fallingItems.length - 1; i >= 0; i--) {
            let item = fallingItems[i];
            let dist = Math.sqrt((pos.x - item.x)**2 + (pos.y - item.y)**2);
            if (dist < item.r + 20) { 
                dragItem = item;
                item.isDragging = true;
                touchOffset = { x: pos.x - item.x, y: pos.y - item.y };
                break;
            }
        }
    } else if (gameState === 'LEVEL2') {
        if (pos.x > submitBtn.x && pos.x < submitBtn.x + submitBtn.w &&
            pos.y > submitBtn.y && pos.y < submitBtn.y + submitBtn.h) {
            evaluateLevel2();
            return;
        }

        for (let i = cards.length - 1; i >= 0; i--) {
            let card = cards[i];
            if (pos.x > card.x && pos.x < card.x + card.w &&
                pos.y > card.y && pos.y < card.y + card.h) {
                dragItem = card;
                card.isDragging = true;
                touchOffset = { x: pos.x - card.x, y: pos.y - card.y };
                
                if(card.slotIndex !== -1) {
                    let slot = slots[card.slotIndex];
                    if(slot.contents.name === card.id) slot.contents.name = null;
                    if(slot.contents.symbol === card.id) slot.contents.symbol = null;
                    if(slot.contents.desc === card.id) slot.contents.desc = null;
                    card.slotIndex = -1;
                }
                break;
            }
        }
    } else if (gameState === 'LEVEL2_RESULT') {
        // åªæœ‰ä¸Šå‚³æˆåŠŸå¾Œï¼Œé»æ“Šå®ŒæˆæŒ‰éˆ•æ‰æœ‰æ•ˆ
        if (uploadStatus === 'success') {
            const pW = Math.min(600, canvas.width - 40);
            const pH = Math.min(500, canvas.height - 40);
            const pX = (canvas.width - pW) / 2;
            const pY = (canvas.height - pH) / 2;
            const btnY = pY + pH - 60;
            const btnX = canvas.width/2 - 80;
            const btnW = 160;
            const btnH = 45;

            if (pos.x > btnX && pos.x < btnX + btnW && pos.y > btnY && pos.y < btnY + btnH) {
                location.reload(); // é‡æ–°æ•´ç†é é¢
            }
        }
    }
}

function handleMove(e) {
    e.preventDefault();
    if (!dragItem) return;
    const pos = getPos(e);
    dragItem.x = pos.x - touchOffset.x;
    dragItem.y = pos.y - touchOffset.y;
}

function handleEnd(e) {
    e.preventDefault();
    if (!dragItem) return;
    
    if (gameState === 'LEVEL1') {
        checkLevel1Drop(dragItem);
    } else if (gameState === 'LEVEL2') {
        checkLevel2Drop(dragItem);
    }
    dragItem.isDragging = false;
    dragItem = null;
}

// ==========================================
// åˆ¤å®šèˆ‡å›é¥‹
// ==========================================

function showFloatingText(text, x, y, color='#fff') {
    feedbacks.push({ text: text, x: x, y: y, life: 60, color: color });
}

// [ä¿®æ”¹] æ–°çš„åˆ¤å®šé‚è¼¯ï¼šä¾æ“šç•«é¢å·¦å³åˆ†å‰²åˆ¤æ–·
function checkLevel1Drop(item) {
    // å·¦é‚Šæ˜¯é‡‘å±¬å€ï¼Œå³é‚Šæ˜¯éé‡‘å±¬å€
    if (item.x < canvas.width / 2) {
        // è½åœ¨å·¦é‚Š (é‡‘å±¬å€)
        if (item.isMetal) {
            removeFallingItem(item); 
            showFloatingText("O", item.x, item.y, '#2ecc71');
        } else {
            // ç­”éŒ¯ï¼šéé‡‘å±¬å»æ‹‰åˆ°å·¦é‚Š
            level1Score = Math.max(0, level1Score - 2); 
            showFloatingText("X", item.x, item.y, '#e74c3c');
            level1Mistakes.push(item.text); 
            // éŒ¯èª¤å¾Œé‡ç½®ä½ç½® (ç°¡å–®å½ˆå›ä¸Šæ–¹æˆ–éš¨æ©Ÿä½ç½®)
            item.y = 50; 
            item.x = Math.random() * (canvas.width - 100) + 50; 
        }
    } else {
        // è½åœ¨å³é‚Š (éé‡‘å±¬å€)
        if (!item.isMetal) {
            removeFallingItem(item); 
            showFloatingText("O", item.x, item.y, '#2ecc71');
        } else {
            // ç­”éŒ¯ï¼šé‡‘å±¬å»æ‹‰åˆ°å³é‚Š
            level1Score = Math.max(0, level1Score - 2);
            showFloatingText("X", item.x, item.y, '#e74c3c');
            level1Mistakes.push(item.text); 
            item.y = 50;
            item.x = Math.random() * (canvas.width - 100) + 50;
        }
    }
}

function removeFallingItem(item) {
    const idx = fallingItems.indexOf(item);
    if (idx > -1) fallingItems.splice(idx, 1);
}

function checkLevel2Drop(card) {
    let hitSlot = null; let hitIndex = -1;
    for (let i = 0; i < slots.length; i++) {
        let s = slots[i];
        if (card.x + card.w/2 > s.x && card.x + card.w/2 < s.x + s.w &&
            card.y + card.h/2 > s.y && card.y + card.h/2 < s.y + s.h) {
            hitSlot = s; hitIndex = i; break;
        }
    }
    
    if (hitSlot) {
        // é˜²æ­¢é‡ç–Š
        if (card.type === 'name' && hitSlot.contents.name) return;
        if (card.type === 'symbol' && hitSlot.contents.symbol) return;
        if (card.type === 'desc' && hitSlot.contents.desc) return;
        
        if (card.type === 'name') {
            card.x = hitSlot.x + 10; card.y = hitSlot.y + 10; hitSlot.contents.name = card.id;
        } else if (card.type === 'symbol') {
            card.x = hitSlot.x + hitSlot.w - card.w - 10; card.y = hitSlot.y + 10; hitSlot.contents.symbol = card.id;
        } else if (card.type === 'desc') {
            card.w = hitSlot.w - 20; card.x = hitSlot.x + 10; card.y = hitSlot.y + 55; hitSlot.contents.desc = card.id;
        }
        card.slotIndex = hitIndex;
    }
}

// ------------------------------------------
// Google Sheet ä¸Šå‚³ä¸²æ¥è¨­å®š
// ------------------------------------------
function submitScore() {
    if(uploadStatus === 'success' || uploadStatus === 'uploading') return;

    // ã€é‡è¦ã€‘è«‹å°‡ä¸‹è¡Œå¼•è™Ÿå…§çš„æ–‡å­—æ›¿æ›ç‚ºæ‚¨çš„ Web App URL
    const scriptURL = 'https://script.google.com/macros/s/AKfycbwouNm1Qmnsf72fpDCz4mDnh63ss12A_N5p7H67ABUIRYyWSQFGk59Z_b-p9k1FEpHH/exec'; 

    if(scriptURL.includes('è«‹åœ¨æ­¤å¡«å…¥')) {
         alert("è€å¸«å°šæœªè¨­å®šå¾Œç«¯ç¶²å€ï¼è«‹è¦‹æ•™å­¸æ–‡ä»¶ã€‚");
         uploadStatus = 'error';
         return;
    }

    uploadStatus = 'uploading'; // è¨­å®šç‚ºä¸Šå‚³ä¸­

    // æ ¼å¼åŒ–éŒ¯é¡Œè¨Šæ¯
    let mistakeStr = "";
    if(level1Mistakes.length > 0) {
        let uniqueL1 = [...new Set(level1Mistakes)];
        mistakeStr += "L1: " + uniqueL1.join("ã€") + "; ";
    }
    if(level2Feedback.length > 0) {
        mistakeStr += "L2: ";
        level2Feedback.forEach(fb => {
             let errs = fb.mistakes.join(",");
             mistakeStr += `${fb.element}(${errs}) `;
        });
    }
    if(mistakeStr === "") mistakeStr = "ç„¡éŒ¯é¡Œ";

    const formData = new FormData();
    formData.append('class', playerInfo.class);
    formData.append('seats', playerInfo.seats);
    formData.append('level1', level1Score);
    formData.append('level2', level2Score);
    formData.append('score', finalScore);
    formData.append('mistakes', mistakeStr);

    fetch(scriptURL, {
        method: 'POST',
        body: formData,
        mode: 'no-cors' 
    })
    .then(() => {
        uploadStatus = 'success'; // ä¸Šå‚³æˆåŠŸ
    })
    .catch(error => {
        console.error('Error:', error);
        uploadStatus = 'error'; // ä¸Šå‚³å¤±æ•—
    });
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    let words = text.split(''); let line = '';
    for(let n = 0; n < words.length; n++) {
        let testLine = line + words[n];
        let metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) {
            ctx.fillText(line, x, y); line = words[n]; y += lineHeight;
        } else { line = testLine; }
    }
    ctx.fillText(line, x, y);
}

function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
    ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r); ctx.closePath();
}
</script>
</body>
</html>